<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Vorpalblade</title>
    <script type="text/javascript"
            src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
    <script src="./lib/rot.js"></script>
    <script>module={};module.exports={};</script>
    <!--script src="https://raw.github.com/ympbyc/js-clos/master/clos.js"></script-->
    <script src="./lib/clos.js"></script>
    <script>CLOS = module.exports;</script>

    <script src="./lib/rangersheck-mapper/array.js"></script>
    <script src="./lib/rangersheck-mapper/lowpro.jquery.js"></script>
    <script src="./lib/rangersheck-mapper/room_template.js"></script>
    <script src="./lib/rangersheck-mapper/mapper.js"></script>

    <link rel="stylesheet" href="./css/vopal.css" />
  </head>
  <body>
    <div id="vorpal-status">
      <div id="vorpal-at">@: You</div>
      <div id="vorpal-health"></div>
      <div class="vorpal-health-text">Health</div>
      <div id="vorpal-depth">-- Depth: 1 --</div>
    </div>
    <div id="rot-container">
    </div>
    <div id="bs-console"></div>
    <div id="biwascheme-debugger"></div>
    <div id="map_display"></div>
    <script src="./lib/biwascheme-min.js">
;;===================( Helpers )==================;;
(define-macro (.. method obj . args)
  `(js-invoke ,obj ',method ,@args))

(define \> js-invocation)

(define (defined? x) (not (js-undefined? x)))

(define ROT (js-eval "ROT"))

(define (construct-eq-hashtable . contents)
  (define (set-fields! ht contents)
    (if (null? contents) ht
        (begin (hashtable-set! ht (car contents) (cadr contents))
               (set-fields! ht (cddr contents)))))
  (let ([size (length contents)])
    (if (= 0 (mod size 2))
        (set-fields! (make-eq-hashtable (/ size 2)) contents)
        (raise "construct-eq-hashtable: arguments must be in the form 'key val key val ...'"))))

(define (add-handler-once! sel ev f)
  (letrec ([handler (add-handler! sel ev (lambda (e)
                                           (remove-handler! sel ev handler)
                                           (f e)))])))

(define-macro (js-lambda args . body)
  `(js-closure (lambda ,args ,@body)))

(define-macro (define-generic name . memoize)
  (let ([mem (if (null? memoize) #f (car memoize))])
    `(define ,name (.. define_generic CLOS ,mem))))

(define-macro (define-method gener argspec . body)
  (let ([args (fold-right (lambda (x acc)
                            (if (pair? x)
                                (cons (cons (cadr x) (car acc))
                                      (cons (car x) (cdr acc)))
                                (cons (cons '(js-eval "undefined") (car acc))
                                      (cons x (cdr acc))))) '(() . ()) argspec)])
    `(.. define_method CLOS
         ,gener
         (list->vector (map eval ',(car args)))
         (js-closure (lambda ,(cdr args) ,@body)))))

(define-macro (define-class name parents . fn)
  (if (null? fn)
      `(define ,name (.. define_class CLOS (list->vector ,parents)))
      `(define ,name (.. define_class CLOS (list->vector ,parents) (js-closure ,(car fn))))))

(define (make class obj)
  (.. make CLOS class obj))

(define (clos-slot-exists x key typ)
  (.. slot_exists CLOS key typ))

(define CLOS (js-eval "CLOS"))


(define-generic _num-pair->key #t) ;for memoization
(define-method _num-pair->key (x y)
  (string-append (number->string x) "," (number->string y)))
(define (num-pair->key x y)
  (js-call _num-pair->key x y))


(define (vector->stream vec)
  (define (aux i)
    (if (= i (vector-length vec))
        '()
        (lambda () (cons (vector-ref vec i) (aux (+ i 1))))))
  (aux 0))

(define (stream-contains? strm x)
  (define (aux strm)
    (if (null? strm) #f
        (let ([ss (strm)])
          (or (eqv? (car ss) x)
              (aux (cdr ss))))))
  (aux strm))

(define (random-int n m)
  (+ (floor (* (\> ROT 'RNG '(getUniform)) n)) m))
(define (random-item vec)
  (vector-ref vec (random-int (vector-length vec) 0)))

;;set
(define (make-set) (make-eqv-hashtable))
(define (set . contents)
  (let ([aSet (make-set)])
    (for-each (lambda (c)
                (hashtable-set! aSet c #t)) contents)
    aSet))
(define (set-contains? s c)
  (hashtable-ref s c #f))
(define (set-add! s c)
  (hashtable-set! s c #t))
(define (set-remove! s c)
  (hashtable-set! s c #f))
(define set-size hashtable-size)
(define set-contents hashtable-keys)
(define (set-for-each f set)
  (vector-for-each (lambda (x)
                         (f x))
                       (set-contents set)))
(define (set-intersect set1 set2)
  (let ([intersection (make-set)])
    (set-for-each (lambda (x)
                           (when (set-contains? set2 x)
                                 (set-add! intersection x)))
                         set1)
    intersection))


(define (key-x key)
  (string->number (car (string-split key ","))))
(define (key-y key)
  (string->number (cadr (string-split key ","))))


(define-record-type (<rgb> make-rgb rgb?)
  (fields (immutable red rgb-red)
          (immutable green rgb-green)
          (immutable blue rgb-blue)))
(define (rgb->css-string c)
  (if (rgb? c)
      (string-append "rgb("
                     (number->string (rgb-red c)) ","
                     (number->string (rgb-green c)) ","
                     (number->string (rgb-blue c)) ")")
      c))
(define (random-close-color base var)
  (make-rgb (+ (rgb-red   base) (random-integer var))
            (+ (rgb-green base) (random-integer var))
            (+ (rgb-blue  base) (random-integer var))))
(define (darker-color base)
  (make-rgb (floor (* 0.5 (rgb-red base)))
            (floor (* 0.5 (rgb-green base)))
            (floor (* 0.5 (rgb-blue base)))))

(define Math (js-eval "Math"))
(define Window (js-eval "window"))

(define-macro (timeout n body)
  `(.. setTimeout Window (js-lambda [] ,body) ,n))


(define (game-map-ref gmap x y default)
  (vector-ref (vector-ref gmap y) x))
(define (game-map-set! gmap x y val)
  (vector-set! (vector-ref gmap y) x val))


(define (floodfill gameMap x y callback)
  (floodfill- gameMap x y (game-map-ref gameMap x y #f) callback))

(define (floodfill- gameMap x y val callback)
  (define (inner acc x y last-x last-y)
    (let ([key (num-pair->key x y)])
      (cond [(memv key acc) acc]
            [(eqv? val (game-map-ref gameMap x y #f))
             (callback  x y)
             (letrec ([a (cons (num-pair->key x y) acc)]
                      [b
                       (if (= (- x 1) last-x) a (inner a (- x 1) y x y))]
                      [c
                       (if (= (+ x 1) last-x) b (inner b (+ x 1) y x y))]
                      [d
                       (if (= (- y 1) last-y) c (inner c x (- y 1) x y))]
                      [e
                       (if (= (+ y 1) last-y) d (inner d x (+ y 1) x y))])
               e)]
            [else
             (callback  x y)
             acc])))
  (inner '()  x y -1 -1))

(define (range low high)
  (if (= low high) '()
      (cons low (range (+ low 1) high))))

(define (vector-for-each/key f vec)
  (for-each
   (lambda [key]
     (f (vector-ref vec key) key))
   (range 0 (vector-length vec))))

(define (draw-cell disp x y ch fgc bgc)
  (if ch (.. draw disp x y ch fgc bgc)))

(define (vector-of-length-more-than? vec n)
  (and (vector? vec)
       (> (vector-length vec) n)))

(define (near-free-cell? freeCells x y)
  (or (set-contains? freeCells (num-pair->key (+ x 1) y))
      (set-contains? freeCells (num-pair->key (- x 1) y))
      (set-contains? freeCells (num-pair->key x (+ y 1)))
      (set-contains? freeCells (num-pair->key x (- y 1)))))

;;====================( End )=====================;;

;;===============( Map Generation )===============;;
(define (make-row width)
  (make-vector width #f))
(define (make-empty-map width height)
  (let ([amap (make-vector height)])
    (for-each
     (lambda [y]
       (vector-set! amap y (make-row width)))
     (range 0 height))
    amap))


(define (digCallback freeCells gameMap)
  (lambda [x y cell]
    (let ([key (num-pair->key x y)])
      (cond
       [(= cell 2) ;door
        (set-add! freeCells key)
        (game-map-set! gameMap x y "+")]
       [(= cell 0) ;floor
        (set-add! freeCells key)
        (game-map-set! gameMap x y ".")]
       [(= cell 3) ;corridor
        (set-add! freeCells key)
        (game-map-set! gameMap x y "\"")]
       [(= cell 1) (game-map-set! gameMap x y "#")]))))


(define (digCallback-third freeCells gameMap)
  (define *x-margin* (floor (div (- *map-width* (* *map-width* 0.6)) 2)))
  (define *y-margin* (floor (div (- *map-height* (* *map-height* 0.6)) 2)))
  (lambda [x y cell]
    (let* ([x (+ x *x-margin*)]
           [y (+ y *y-margin*)]
           [key (num-pair->key x y)])
      (cond [(= cell 1)
             (set-add! freeCells key)
             (game-map-set! gameMap x y "~")]
            [(and (not (game-map-ref gameMap x y #f))
                  (near-free-cell? freeCells x y))
             (game-map-set! gameMap x y "#")]))))

(define (map-gen seed)
  (\> ROT
      'RNG
      `(setSeed ,seed))
  (let ([aMap (js-new "ROT.Map.Rangersheck" *map-width* *map-height*)]
        [freeCells (make-set)]
        [gameMap  (make-empty-map *map-width* *map-height*)]
        [bMap (js-new "ROT.Map.Cellular" (* 0.6 *map-width* ) (* 0.6 *map-height*))])
    (.. create aMap (js-closure (digCallback freeCells gameMap)))
    (.. randomize bMap 0.45)
    (for-each (lambda (_)
           #|(.. create (car room)
           (js-closure (digCallback-second freeCells gameMap)))|#
           (.. create bMap (js-closure (digCallback-third freeCells gameMap)))
                ) (iota 6))
    (console-log gameMap)
    (values freeCells gameMap)))

(define (room-gen-random)
  (let ([door-x (random-int (- *map-width* 20)  1)]
        [door-y (random-int (- *map-height* 7) 1)])
    (cons
     (\> ROT
        'Map
        'Feature
        'Room
        `(createRandomAt ,door-x
                         ,door-y
                         ,(random-item (vector 1 -1))
                         ,(random-item (vector 1 -1))
                         ,(js-obj "roomWidth" (vector (random-int 4 5)
                                                      (random-int 20 5))
                                  "roomHeight" (vector (random-int 3 3)
                                                       (random-int 7 5)))))
     (cons door-x door-y))))

;;=================( Datatype  )==================;;
;;player has to be represented as a js object due to the lib we are using
(define-class <rot-actor> '() (lambda [x]
                               (and (clos-slot-exists x 'getSpeed "function")
                                    (clos-slot-exists x 'act "function"))))
(define-class <creature> `(,<rot-actor>) (lambda [p]
                            (and (clos-slot-exists p 'x "number")
                                 (clos-slot-exists p 'y "number"))))
(define-class <player> `(,<creature>))
(define-class <enemy>  `(,<creature>))

(define (creature-x cr)
  (js-ref cr 'x))
(define (creature-y cr)
  (js-ref cr 'y))

;;=================( Creatures )==================;;
(define (make-creature <class> x y gameMap freeCells)
  (letrec ([creature (make <class>
                       (js-obj
                        "x"        x
                        "y"        y
                        "getSpeed" (js-lambda [] (js-call get-speed creature))
                        "act"      (js-lambda [] (js-call rot-act creature gameMap freeCells))))])
    creature))

(define (within-distance? cr1 cr2 distance)
  (and
   (< (abs (- (creature-x cr1) (creature-x cr2))) distance)
   (< (abs (- (creature-y cr1) (creature-y cr2))) distance)))


;;=================( Actor Spec )=================;;
(define-generic get-speed)
(define-method get-speed ([pl <player>]) 100)
(define-method get-speed ([pl <enemy>]) 100)

(define-generic rot-act)


(define-method rot-act ([pl <player>] gameMap freeCells)
  (.. lock *GAME-engine*)
  (add-handler-once! "body"
                     "keydown"
                     (lambda [e]
                       (player-movement e pl gameMap freeCells)
                       (draw-fov gameMap freeCells (creature-x pl) (creature-y pl))
                       (js-call creature-draw pl)
                       (draw-status pl)
                       (.. unlock *GAME-engine*))))

(define-method rot-act ([en <enemy>] gameMap freeCells)
  (enemy-movement en gameMap freeCells)
  (when (within-distance? (game-player) en *visibility-distance*)
        (js-call creature-draw en)))


;;=============( Creature Generation )============;;
;;clean and functional
(define (creature-init <class> gameMap freeCells)
  (let* ([index (floor (* (\> ROT 'RNG '(getUniform))
                          (set-size freeCells)))]
         [key (vector-ref (set-contents freeCells) index)]
         [parts (string-split key ",")]
         [x (string->number (car parts))]
         [y (string->number (cadr parts))])
    (make-creature <class> x y gameMap freeCells)))


;;==============( Player Movement )===============;;
;;Draws to the map
;;mutates player object
(define (player-movement e pl gameMap freeCells)
  (let ([direction (hashtable-ref *keymap* (js-ref e 'keyCode) #f)])
    (if direction
        (let* ([diff (vector-ref (js-ref (js-ref ROT 'DIRS) "8") direction)]
               [cur-x (creature-x pl)]
               [cur-y (creature-y pl)]
               [cur-key (num-pair->key cur-x cur-y)]
               [new-x (+ cur-x (vector-ref diff 0))]
               [new-y (+ cur-y (vector-ref diff 1))]
               [new-key (num-pair->key new-x new-y)])
          (set-add! freeCells cur-key) ;free current cell
          (if (set-contains? freeCells new-key)
              (let ([char (game-map-ref gameMap cur-x cur-y ".")])
                (draw-colored-char cur-x cur-y char)
                (set-remove! freeCells new-key) ;reserve new cell
                (js-set! pl "x" new-x)
                (js-set! pl "y" new-y))
              pl))
        pl)))

;;===============( Enemy Movement )===============;;
(define (char-passable? ch)
  (set-contains? *creature-pass-char* ch))

(define (enemy-movement en gameMap freeCells)
  (define passbale-callback (js-lambda [x y]
        (char-passable? (game-map-ref gameMap x y #f))))
  (define (path-callback path) (js-lambda [x y]
                                          (.. push path (vector x y))))
  (let* ([x (creature-x (game-player))]
         [y (creature-y (game-player))]
         [cur-x (creature-x en)]
         [cur-y (creature-y en)]
         [cur-key (num-pair->key cur-x cur-y)]
         [path (make-vector 0)]
         [cached-path (js-ref en "_cached_path")]
         [astar (js-new "ROT.Path.AStar" x y passbale-callback (js-obj "topology" 8))])
    (set-add! freeCells cur-key)         ;free current cell
    (when (within-distance? (game-player) en 10)
          (if (vector-of-length-more-than? cached-path 5)
              (set! path cached-path)
              (.. compute astar cur-x cur-y (path-callback path)))
          (cond [(<= (vector-length path) 0)
                 (.. removeActor *GAME-engine* en)] ;kill if unreachable
                [(> (vector-length path) 2)
                 (.. shift path) ;remove current position
                 (let* ([new-x (vector-ref (vector-ref path 0) 0)]
                        [new-y (vector-ref (vector-ref path 0) 1)]
                        [char (game-map-ref gameMap cur-x cur-y ".")]
                        [new-key (num-pair->key new-x new-y)])
                   (draw-colored-char cur-x cur-y char) ;free current cell
                   (when (set-contains? freeCells new-key)
                         (set-remove! freeCells (num-pair->key new-x new-y)) ;reserve
                         (js-set! en "_cached_path" path)
                         (js-set! en "x" new-x)
                         (js-set! en "y" new-y)))]))))

;;====================( FOV )=====================;;
(define (light-passes? gameMap)
  (define-generic l-pass #t) ;memoize
  (define-method l-pass (x y)
    (let ([cell (game-map-ref gameMap x y "#")])
      (set-contains? *light-pass-char* cell)))
  l-pass)

(define memoized-light-passes #f)

(define *drawn-fov* (make-set))
(define *fov-redraw-everytime* (set "~" "+"))

(define *currently-lit* (make-set))

(define (draw-lit cur-lit next-lit gameMap)
  (set-for-each (lambda (key)
                  (let* ([x (key-x key)]
                         [y (key-y key)]
                         [ch (game-map-ref gameMap x y "#")])
                    (if (or (eqv? ch "~")
                            (not (set-contains? cur-lit key)))
                            (draw-colored-char
                             x y
                             ch))))
                next-lit))
(define (draw-darker cur-lit next-lit gameMap)
  (set-for-each (lambda (key)
                  (let ([x (key-x key)]
                        [y (key-y key)])
                    (unless (set-contains? next-lit key)
                            (draw-colored-char-darker
                             x y
                             (game-map-ref gameMap x y "#")))))
                cur-lit))


;responsible only for the dungeon.
(define (draw-fov gameMap freeCells pl-x pl-y)
  (or memoized-light-passes
      (set! memoized-light-passes (light-passes? gameMap)))
  (let ([key (num-pair->key pl-x pl-y)]
        [cell (game-map-ref gameMap pl-x pl-y #f)]
        [fov (js-new "ROT.FOV.PreciseShadowcasting" memoized-light-passes)]
        [next-lit (make-set)])
    (cond [(and (eqv? cell ".")
                (not (set-contains? *currently-lit* key)))
           (draw-floodfill gameMap pl-x pl-y)]
     #;[(eqv? cell ".") #f]
     [(or (set-contains? *fov-redraw-everytime* cell)
          (not (set-contains? *drawn-fov* key)))
      (set-add! *drawn-fov* key)
      (.. compute fov pl-x pl-y *visibility-distance*
          (js-lambda [x y r v]
                     (set-add! next-lit (num-pair->key x y))))
      (draw-lit *currently-lit* next-lit gameMap)
      (draw-darker *currently-lit* next-lit gameMap)
      (set! *currently-lit* next-lit)])))

(define (draw-floodfill gameMap pl-x pl-y)
  (floodfill gameMap pl-x pl-y
             (lambda [x y]
               (set-add! *currently-lit* (num-pair->key x y))
               (draw-colored-char
                x y
                (game-map-ref gameMap x y "#")))))



;;==================(  Visual )===================;;
(define *char-color* (construct-eq-hashtable
                      "#" (make-rgb 34 34 34)
                      "." (make-rgb 255 255 255)
                      "\"" (make-rgb 105 212 85)
                      "+" (make-rgb 245 113 37)
                      "~" (make-rgb 135 115 255))) ;blue
(define *char-bg-color* (construct-eq-hashtable
                         "#" (make-rgb 192 169 179)
                         "." (make-rgb 18 18 44)
                         "\"" (make-rgb 13 8 33)
                         "+" (make-rgb 117 38 18)
                         "~" (make-rgb 38 54 138))) ;light blue
(define (char-color ch)
  (hashtable-ref *char-color* ch (make-rgb 255 255 255)))
(define (char-bg-color ch)
  (hashtable-ref *char-bg-color* ch (make-rgb 255 255 255)))

(define *variate-color* (set "#" "~" "\""))
(define (variate-color? ch)
  (set-contains? *variate-color* ch))

(define (draw-colored-char x y ch)
  (let ([chc  (char-color ch)]
        [chbc (char-bg-color ch)])
    (if (and (variate-color? ch) (< (.. random Math) 0.2))
        (draw-colored-char-variation x y ch chc chbc)
        (draw-cell *GAME-display* x y ch
          (rgb->css-string chc)
          (rgb->css-string chbc)))))

(define (draw-colored-char-variation x y ch chc chbc)
  (timeout
   100
   (draw-cell *GAME-display* x y ch
       (rgb->css-string (random-close-color chc 40))
       (rgb->css-string (random-close-color chbc 40)))))

(define (draw-colored-char-darker x y ch)
  (let ([chc (char-color ch)]
        [chbc (char-bg-color ch)])
    (draw-cell *GAME-display* x y ch
               (rgb->css-string (darker-color chc))
               (rgb->css-string (darker-color chbc)))))

;;=====================( IO )=====================;;
(define (draw-whole-map gameMap)
  (vector-for-each/key (lambda [row y]
    (vector-for-each/key (lambda [chr x]
      (draw-colored-char x y chr)) row))
     gameMap))

(define-generic creature-draw)
(define-method  creature-draw ([pl <player>])
  (draw-cell *GAME-display*
      (creature-x pl)
      (creature-y pl)
      "@"
      "#e0baf6"
      "#000"))
(define-method  creature-draw ([en <enemy>])
  (draw-cell *GAME-display*
      (creature-x en)
      (creature-y en)
      "f"
      "#f57125"
      "#000"))

(define $vorpal-at ($ "#vorpal-at"))
(define $vorpal-health ($ "#vorpal-health"))

(define (draw-status player)
  (.. width $vorpal-health 250))

;;;;        You found a vorpal blade!
;;;;
;;;;              ############
;;;;              #..........#
;;;;              #....@.....#
;;;;              #.......>..#
;;;;              ############
;;;;
;;;; ympbyc the Programmer    Chaotic human hacker

;;===================( Config )===================;;
(define *map-width* 75)
(define *map-height* 35)
(define *seed* 1236)
(define *path-cache-duration* 10)
(define *visibility-distance* 8)
(define *GAME-display* (js-new "ROT.Display" (js-obj  "fontSize" 16
                                                      "fontFamily" "Monaco"
                                                      "textBaseline" "middle"
                                                      "lineHeight" "2em"
                                                      "width" *map-width*
                                                      "height" *map-height*)))
(define *GAME-engine* (js-new "ROT.Engine"))
(define *keymap* (construct-eq-hashtable
                  89 7    ;y
                  75 0    ;k
                  85 1    ;u
                  76 2    ;l
                  78 3    ;n
                  74 4    ;j
                  66 5    ;b
                  72 6))  ;h
(define *objects* (construct-eq-hashtable
                   'player #f
                   'enemies '()))
(define (game-player) (hashtable-ref *objects* 'player #f))
(define (game-enemies) (hashtable-ref *objects* 'enemies #f))

(define *light-pass-char* (set "." "~" "\""))
(define *creature-pass-char* (set "." "~" "+" "\""))


;;================( Game Engine )=================;;
(define (game-init gameMap freeCells)
  (let ([pl (creature-init <player> gameMap freeCells)])
    (.. addActor *GAME-engine* pl)
    (hashtable-set! *objects* 'player pl)
    (js-call creature-draw pl))
  (hashtable-set! *objects* 'enemies
                  (map (lambda (_)
                         (let ([en (creature-init <enemy> gameMap freeCells)])
                           (.. addActor *GAME-engine* en)
                           (js-call creature-draw en)
                           en)) (iota 1)))
  (.. start *GAME-engine*))


;;===================(  Main )====================;;
((lambda []
   (element-insert! "#rot-container" (.. getContainer *GAME-display*)) ;;add canvas to html
   (let-values ([[freeCells gameMap] (map-gen *seed*)])
     ;(draw-whole-map gameMap)
     (game-init gameMap freeCells))))

    </script>
  </body>
</html>
